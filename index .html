<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>æ–¹åŠ‘çµ„æˆæœå°‹ï¼ˆv2ï¼‰</title>
  <style>
    body { font-family: system-ui, -apple-system, "Noto Sans TC", Arial; margin: 24px; line-height: 1.5; }
    textarea, input { box-sizing: border-box; }
    textarea { width: 100%; min-height: 120px; padding: 12px; font-size: 16px; }
    button { padding: 10px 14px; font-size: 16px; cursor: pointer; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }
    .muted { color: #666; font-size: 14px; }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 12px 14px; margin-top: 14px; }
    .tag { display: inline-block; padding: 2px 8px; border: 1px solid #ddd; border-radius: 999px; margin: 2px 6px 2px 0; font-size: 13px; }
    .good { border-color: #8fd19e; background: #f1fff5; }
    .warn { border-color: #ffd28a; background: #fff9ef; }
    .bad  { border-color: #ff9f9f; background: #fff3f3; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .grid2 { display:grid; grid-template-columns: 1fr; gap: 12px; }
    @media (min-width: 980px){ .grid2 { grid-template-columns: 1fr 1fr; } }
    .pill { display:inline-flex; align-items:center; gap:8px; padding:8px 10px; border:1px solid #ddd; border-radius:999px; }
    .small { font-size: 13px; }
    .divider { height:1px; background:#eee; margin:12px 0; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; border:1px solid #ddd; border-bottom-width:2px; padding:0 6px; border-radius:6px; background:#fafafa; }
  </style>
</head>
<body>
  <h1>æ–¹åŠ‘çµ„æˆæœå°‹ï¼ˆv2ï¼‰</h1>
  <p class="muted">
    æ”¯æ´è¼¸å…¥æ ¼å¼ï¼š<span class="kbd">é€—è™Ÿ/é “è™Ÿ/æ›è¡Œ</span>ã€<span class="kbd">ç©ºç™½åˆ†éš”ï¼ˆå«å…¨å½¢ç©ºç™½ï¼‰</span>ã€<span class="kbd">è—¥åç·Šè²¼æ•¸å­—åŠ‘é‡</span>ï¼ˆä¾‹ï¼šå±±èŒ±è¸3ç‰ç«¹2â€¦ï¼‰ã€‚
    åŠŸèƒ½ï¼šâ‘  è—¥å‘³æ¯”å°æ‰¾æœ€ç¬¦åˆæ–¹ â‘¡ æ–¹åé—œéµå­—æœå°‹ â‘¢ åˆæ–¹åˆ¤æ–·ï¼ˆæœ€å¤šå…©æ–¹ï¼‰
  </p>

  <div class="grid2">
    <div class="card">
      <div style="font-weight:800; margin-bottom:8px;">A) è—¥å‘³è¼¸å…¥ â†’ æ‰¾æœ€ç¬¦åˆæ–¹ / åˆæ–¹</div>
      <textarea id="input" placeholder="ä¾‹1ï¼šå±±èŒ±è¸ã€ç‰ç«¹ã€ä½•é¦–çƒã€æ²™åƒåŒ—ã€æ¸æã€éº¥é–€å†¬ã€èŸçµ²å­ã€èŒ¯è‹“
ä¾‹2ï¼šå±±èŒ±è¸ã€€ç‰ç«¹ã€€ä½•é¦–çƒã€€æ²™åƒåŒ—ã€€æ¸æã€€éº¥é–€å†¬ã€€èŸçµ²å­ã€€èŒ¯è‹“
ä¾‹3ï¼šå±±èŒ±è¸3ç‰ç«¹2ä½•é¦–çƒ4æ²™åƒåŒ—5æ¸æ6éº¥é–€å†¬7èŸçµ²å­3èŒ¯è‹“5"></textarea>

      <div class="row" style="margin-top: 10px;">
        <button id="searchBtn">æœå°‹</button>
        <button id="clearBtn" type="button">æ¸…ç©º</button>

        <span class="pill muted small">
          é¡¯ç¤ºå‰
          <input id="topN" type="number" min="1" max="50" value="10" style="width:70px; padding:6px;" />
          ç­†
        </span>

        <span class="pill muted small">
          æœ€ä½è¦†è“‹ç‡
          <input id="minCoverage" type="number" min="0" max="1" step="0.05" value="0.4" style="width:80px; padding:6px;" />
          ï¼ˆ0~1ï¼‰
        </span>

        <span class="pill muted small">
          <input id="enableCombo" type="checkbox" checked />
          å•Ÿç”¨åˆæ–¹
        </span>

        <span class="pill muted small">
          åˆæ–¹å€™é¸æ–¹æ•¸
          <input id="comboCandidates" type="number" min="20" max="500" value="120" style="width:90px; padding:6px;" />
        </span>

        <span class="pill muted small">
          åˆæ–¹é–€æª»(precisionæå‡)
          <input id="comboGain" type="number" min="0" max="0.5" step="0.01" value="0.08" style="width:90px; padding:6px;" />
        </span>
      </div>

      <div id="status" class="muted" style="margin-top: 10px;"></div>
      <div id="parsed" class="muted" style="margin-top: 8px;"></div>
      <div id="results"></div>
    </div>

    <div class="card">
      <div style="font-weight:800; margin-bottom:8px;">B) æ–¹åé—œéµå­—æœå°‹ï¼ˆè¼¸å…¥å­—å°±èƒ½æ‰¾ï¼‰</div>
      <input id="nameQuery" type="text" placeholder="è¼¸å…¥æ–¹åé—œéµå­—ï¼Œä¾‹å¦‚ï¼šæ¡‚æ / æ‰¿æ°£ / é€é™"
             style="width:100%; padding:10px; font-size:16px;" />
      <div class="muted" style="margin-top:6px;">
        æœƒåˆ—å‡ºåŒ¹é…æ–¹åï¼›é»ä¸€ä¸‹å¯å°‡è©²æ–¹è—¥å‘³å¸¶å…¥å·¦å´è¼¸å…¥æ¡†ä¸¦è‡ªå‹•æœå°‹ã€‚
      </div>
      <div id="nameResults"></div>
      <div class="divider"></div>
      <div class="muted small">
        å°æŠ€å·§ï¼šä½ ä¹Ÿå¯ä»¥åªç”¨æ–¹åæœå°‹ä¾†ç¢ºèªè³‡æ–™åº«ä¸­æ˜¯å¦å­˜åœ¨æŸæ–¹ã€‚
      </div>
    </div>
  </div>

<script>
  // =========================
  // Cache
  // =========================
  let FORMULAS_CACHE = [];
  let FORMULAS_LOADED = false;

  // =========================
  // Normalization & parsing (æ”¯æ´ 3 ç¨®è¼¸å…¥æ ¼å¼)
  // =========================
  function normalizeHerbName(s) {
    return (s || "").trim().replace(/\s+/g, "");
  }

  function parseHerbList(text) {
    // 1) çµ±ä¸€åˆ†éš”ç¬¦ç‚ºç©ºç™½ï¼šé€—è™Ÿã€é “è™Ÿã€åˆ†è™Ÿã€æ›è¡Œã€å…¨å½¢ç©ºç™½éƒ½è½‰æˆç©ºç™½
    let t = (text || "")
      .replace(/[ï¼Œã€ï¼›;]+/g, " ")
      .replace(/\r?\n+/g, " ")
      .replace(/\u3000+/g, " "); // å…¨å½¢ç©ºç™½

    // 2) æŠŠåŠ‘é‡/æ•¸å­—/å°æ•¸é»/å¸¸è¦‹å–®ä½å…¨éƒ¨è½‰æˆç©ºç™½
    //    é€™ä¸€æ­¥æœƒæŠŠï¼šå±±èŒ±è¸3ç‰ç«¹2 è®Šæˆ å±±èŒ±è¸ ç‰ç«¹
    t = t.replace(/[0-9ï¼-ï¼™]+(\.[0-9ï¼-ï¼™]+)?/g, " "); // æ•¸å­—èˆ‡å°æ•¸
    t = t.replace(/(gm|g|ml|cc|éŒ¢|å…©|åˆ†|æ–¤|å…‹|æ¯«å‡|å…¬å…‹)/gi, " "); // å¸¸è¦‹å–®ä½ï¼ˆå¯è‡ªè¡Œæ“´å……ï¼‰

    // 3) å¤šç©ºç™½ç¸®æˆ 1 å€‹
    t = t.replace(/\s+/g, " ").trim();

    // 4) ä»¥ç©ºç™½åˆ‡é–‹ â†’ å€™é¸è—¥åæ¸…å–®
    const raw = t.split(" ").map(normalizeHerbName).filter(Boolean);

    // 5) å»é‡ï¼ˆä¿ç•™è¼¸å…¥é †åºï¼‰
    const seen = new Set();
    const out = [];
    for (const h of raw) {
      if (!seen.has(h)) { seen.add(h); out.push(h); }
    }
    return out;
  }

  // å…¼å®¹è³‡æ–™æ ¼å¼ï¼š
  // A) {name, herbs:["æ¡‚æ","èŠè—¥"...]}
  // B) {name, items:[{herb:"æ¡‚æ", dose:0.5}...]}
  function getHerbList(formula) {
    if (Array.isArray(formula.herbs)) return formula.herbs.map(normalizeHerbName).filter(Boolean);
    if (Array.isArray(formula.items)) return formula.items.map(x => normalizeHerbName(x.herb)).filter(Boolean);
    return [];
  }

  async function loadFormulas() {
    if (FORMULAS_LOADED) return FORMULAS_CACHE;

    const res = await fetch("./formulas.json", { cache: "no-store" });
    if (!res.ok) throw new Error("ç„¡æ³•è®€å– formulas.jsonï¼ˆè«‹ç¢ºèªæª”æ¡ˆå­˜åœ¨ä¸”èˆ‡ index.html åŒå±¤ï¼‰");
    const data = await res.json();

    const formulas = data.map(x => ({
      name: x.name || x.çµ„å¥— || x.title || "ï¼ˆæœªå‘½åï¼‰",
      herbs: getHerbList(x)
    })).filter(x => x.name && x.herbs.length);

    FORMULAS_CACHE = formulas;
    FORMULAS_LOADED = true;
    return FORMULAS_CACHE;
  }

  // =========================
  // Scoring
  // =========================
  // coverage = matched / formula_size
  // precision = matched / input_size
  // score = coverage*0.75 + precision*0.25 (åé‡æ–¹å…§è¦†è“‹)
  function scoreFormula(inputSet, formulaHerbs) {
    const fSet = new Set(formulaHerbs);
    let matched = 0;
    for (const h of inputSet) if (fSet.has(h)) matched++;

    const coverage = formulaHerbs.length ? matched / formulaHerbs.length : 0;
    const precision = inputSet.size ? matched / inputSet.size : 0;
    const score = coverage * 0.75 + precision * 0.25;

    const missing = formulaHerbs.filter(h => !inputSet.has(h));
    const extras = [...inputSet].filter(h => !fSet.has(h));

    return { matched, coverage, precision, score, missing, extras };
  }

  // åˆæ–¹ï¼ˆå…©æ–¹ unionï¼‰
  // score = precision*0.65 + coverage*0.35 (åé‡æŠŠä½ çš„è¼¸å…¥è§£é‡‹æ‰)
  function scoreCombo(inputSet, herbsA, herbsB) {
    const union = new Set([...herbsA, ...herbsB]);
    let matched = 0;
    for (const h of inputSet) if (union.has(h)) matched++;

    const unionList = [...union];
    const coverage = unionList.length ? matched / unionList.length : 0;
    const precision = inputSet.size ? matched / inputSet.size : 0;
    const score = precision * 0.65 + coverage * 0.35;

    const missing = unionList.filter(h => !inputSet.has(h));
    const extras = [...inputSet].filter(h => !union.has(h));

    return { matched, coverage, precision, score, missing, extras, unionList };
  }

  function badgeClass(coverage) {
    if (coverage >= 0.8) return "good";
    if (coverage >= 0.5) return "warn";
    return "bad";
  }

  // =========================
  // Rendering helpers
  // =========================
  function escapeHtml(s){
    return (s||"").replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
  }

  function renderTags(list) {
    if (!list.length) return `<span class="muted">ï¼ˆç„¡ï¼‰</span>`;
    return list.map(x => `<span class="tag">${escapeHtml(x)}</span>`).join("");
  }

  function renderResult(item) {
    const { formula, stat } = item;
    const pct = (v) => (Math.round(v * 1000) / 10).toFixed(1) + "%";

    const addOn = stat.extras.length ? ` + ${stat.extras.join("ã€")}` : "";
    const title = `${formula.name}${addOn}`;

    return `
      <div class="card ${badgeClass(stat.coverage)}">
        <div style="font-size:18px; font-weight:700;">${escapeHtml(title)}</div>
        <div class="muted mono" style="margin-top:6px;">
          è¦†è“‹ç‡(æ–¹å…§å‘½ä¸­)ï¼š${pct(stat.coverage)}ã€€
          ç²¾æº–ç‡(è¼¸å…¥å‘½ä¸­)ï¼š${pct(stat.precision)}ã€€
          ç¶œåˆåˆ†æ•¸ï¼š${(Math.round(stat.score*1000)/10).toFixed(1)}
        </div>

        <div style="margin-top:10px;">
          <div><b>æ–¹åŠ‘çµ„æˆ</b>ï¼š${renderTags(formula.herbs)}</div>
          <div style="margin-top:6px;"><b>ä½ è¼¸å…¥çš„åŠ å‘³ï¼ˆå¤šå‡ºï¼‰</b>ï¼š${renderTags(stat.extras)}</div>
          <div style="margin-top:6px;"><b>ä½ ç¼ºå°‘çš„æ–¹å…§è—¥å‘³</b>ï¼š${renderTags(stat.missing)}</div>
        </div>
      </div>
    `;
  }

  function highlight(text, q){
    if (!q) return escapeHtml(text);
    const idx = text.toLowerCase().indexOf(q.toLowerCase());
    if (idx < 0) return escapeHtml(text);
    const a = escapeHtml(text.slice(0, idx));
    const b = escapeHtml(text.slice(idx, idx + q.length));
    const c = escapeHtml(text.slice(idx + q.length));
    return `${a}<span style="background:#fff2a8; padding:0 2px; border-radius:4px;">${b}</span>${c}`;
  }

  // =========================
  // Feature 1: Herb-based search + combo
  // =========================
  async function runSearch() {
    const statusEl = document.getElementById("status");
    const parsedEl = document.getElementById("parsed");
    const resultsEl = document.getElementById("results");
    resultsEl.innerHTML = "";
    parsedEl.textContent = "";
    statusEl.textContent = "è®€å–æ–¹åŠ‘è³‡æ–™ä¸­â€¦";

    const inputHerbs = parseHerbList(document.getElementById("input").value);
    const inputSet = new Set(inputHerbs);

    parsedEl.innerHTML = inputHerbs.length
      ? `<b>è§£æåˆ°çš„è—¥å</b>ï¼š${inputHerbs.map(h=>`<span class="tag">${escapeHtml(h)}</span>`).join("")}`
      : "";

    if (inputSet.size === 0) {
      statusEl.textContent = "è«‹å…ˆè¼¸å…¥è‡³å°‘ 1 å‘³è—¥ã€‚";
      return;
    }

    let formulas;
    try {
      formulas = await loadFormulas();
    } catch (e) {
      statusEl.textContent = e.message;
      return;
    }

    const topN = Math.max(1, Math.min(50, Number(document.getElementById("topN").value || 10)));
    const minCoverage = Math.max(0, Math.min(1, Number(document.getElementById("minCoverage").value || 0)));
    const enableCombo = document.getElementById("enableCombo").checked;
    const comboGain = Math.max(0, Math.min(0.5, Number(document.getElementById("comboGain").value || 0.08)));

    const scored = formulas.map(f => {
      const stat = scoreFormula(inputSet, f.herbs);
      return { formula: f, stat };
    }).filter(x => x.stat.coverage >= minCoverage);

    scored.sort((a,b) => b.stat.score - a.stat.score || b.stat.coverage - a.stat.coverage);

    statusEl.textContent =
      `è¼¸å…¥è—¥å‘³ï¼š${inputHerbs.join("ã€")} ï½œ å…±æ¯”å° ${formulas.length} æ–¹ ï½œ é¡¯ç¤º ${Math.min(topN, scored.length)} ç­†`;

    // --- åˆæ–¹åˆ¤æ–·ï¼ˆæœ€å¤šå…©æ–¹ï¼‰ ---
    let comboHtml = "";
    if (enableCombo && scored.length >= 2) {
      const candidatesN = Math.max(20, Math.min(500, Number(document.getElementById("comboCandidates").value || 120)));
      const candidates = scored.slice(0, candidatesN);

      let best = null;
      for (let i = 0; i < candidates.length; i++) {
        for (let j = i + 1; j < candidates.length; j++) {
          const A = candidates[i].formula;
          const B = candidates[j].formula;

          const stat = scoreCombo(inputSet, A.herbs, B.herbs);

          // åˆæ–¹å¿…é ˆé¡¯è‘—æå‡ã€Œè¼¸å…¥å‘½ä¸­ã€ï¼ˆprecisionï¼‰æ‰æ¨è–¦
          const bestSingle = scored[0].stat;
          const precisionGain = stat.precision - bestSingle.precision;
          if (precisionGain < comboGain) continue;

          const candidate = { A, B, stat };
          if (!best || candidate.stat.score > best.stat.score) best = candidate;
        }
      }

      const pct = (v) => (Math.round(v * 1000) / 10).toFixed(1) + "%";
      if (best) {
        const title = `${best.A.name} åˆ ${best.B.name}` + (best.stat.extras.length ? ` + ${best.stat.extras.join("ã€")}` : "");
        comboHtml = `
          <div class="card good">
            <div style="font-size:18px; font-weight:800;">ğŸ”¥ æ¨è–¦åˆæ–¹ï¼š${escapeHtml(title)}</div>
            <div class="muted mono" style="margin-top:6px;">
              è¦†è“‹ç‡(åˆæ–¹å‘½ä¸­)ï¼š${pct(best.stat.coverage)}ã€€
              ç²¾æº–ç‡(è¼¸å…¥å‘½ä¸­)ï¼š${pct(best.stat.precision)}ã€€
              ç¶œåˆåˆ†æ•¸ï¼š${(Math.round(best.stat.score*1000)/10).toFixed(1)}
            </div>
            <div style="margin-top:10px;">
              <div><b>æ–¹ A</b>ï¼š${renderTags(best.A.herbs)}</div>
              <div style="margin-top:6px;"><b>æ–¹ B</b>ï¼š${renderTags(best.B.herbs)}</div>
              <div style="margin-top:8px;"><b>åˆæ–¹ç¼ºå°‘çš„è—¥å‘³</b>ï¼š${renderTags(best.stat.missing)}</div>
              <div style="margin-top:6px;"><b>ä½ çš„åŠ å‘³ï¼ˆå¤šå‡ºï¼‰</b>ï¼š${renderTags(best.stat.extras)}</div>
            </div>
          </div>
        `;
      } else {
        comboHtml = `
          <div class="card warn">
            <div style="font-weight:700;">åˆæ–¹åˆ¤æ–·ï¼šæš«æ™‚æ²’æœ‰æ‰¾åˆ°ã€Œæ˜é¡¯å„ªæ–¼å–®æ–¹ã€çš„å…©æ–¹çµ„åˆ</div>
            <div class="muted" style="margin-top:6px;">
              å¯å˜—è©¦ï¼šæé«˜ã€Œåˆæ–¹å€™é¸æ–¹æ•¸ã€ã€é™ä½ã€Œæœ€ä½è¦†è“‹ç‡ã€ã€æˆ–è¼¸å…¥æ›´å®Œæ•´è—¥å‘³ï¼›ä¹Ÿå¯æŠŠã€Œåˆæ–¹é–€æª»ã€èª¿å°ã€‚
            </div>
          </div>
        `;
      }
    }

    resultsEl.innerHTML = comboHtml + (scored.slice(0, topN).map(renderResult).join("")
      || `<div class="card">æ²’æœ‰ç¬¦åˆæœ€ä½è¦†è“‹ç‡ï¼ˆ${minCoverage}ï¼‰çš„çµæœï¼Œè«‹é™ä½é–€æª»æˆ–å¢åŠ æ–¹åŠ‘è³‡æ–™ã€‚</div>`);
  }

  // =========================
  // Feature 2: Name keyword search
  // =========================
  async function runNameSearch() {
    const box = document.getElementById("nameResults");
    const q = (document.getElementById("nameQuery").value || "").trim();
    box.innerHTML = "";

    if (!q) return;

    let formulas;
    try {
      formulas = await loadFormulas();
    } catch (e) {
      box.innerHTML = `<div class="card bad">${escapeHtml(e.message)}</div>`;
      return;
    }

    const hits = formulas
      .filter(f => f.name.toLowerCase().includes(q.toLowerCase()))
      .slice(0, 30);

    if (!hits.length) {
      box.innerHTML = `<div class="muted">æ‰¾ä¸åˆ°åŒ…å«ã€Œ${escapeHtml(q)}ã€çš„æ–¹åã€‚</div>`;
      return;
    }

    box.innerHTML = hits.map(f => `
      <div class="card" style="margin-top:8px; cursor:pointer;" data-name="${escapeHtml(f.name)}">
        <div style="font-weight:700;">${highlight(f.name, q)}</div>
        <div class="muted" style="margin-top:6px;">${f.herbs.map(h => `<span class="tag">${escapeHtml(h)}</span>`).join("")}</div>
      </div>
    `).join("");

    box.querySelectorAll("[data-name]").forEach(el => {
      el.addEventListener("click", async () => {
        const name = el.getAttribute("data-name");
        const found = formulas.find(x => x.name === name);
        if (!found) return;
        document.getElementById("input").value = found.herbs.join("ã€");
        await runSearch();
        window.scrollTo({ top: 0, behavior: "smooth" });
      });
    });
  }

  // =========================
  // Events
  // =========================
  document.getElementById("searchBtn").addEventListener("click", runSearch);
  document.getElementById("clearBtn").addEventListener("click", () => {
    document.getElementById("input").value = "";
    document.getElementById("status").textContent = "";
    document.getElementById("parsed").textContent = "";
    document.getElementById("results").innerHTML = "";
  });
  document.getElementById("nameQuery").addEventListener("input", runNameSearch);

  // optional: preload formulas quietly
  loadFormulas().catch(()=>{});
</script>

</body>
</html>
